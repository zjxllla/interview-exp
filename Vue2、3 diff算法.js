vue2：
采用首尾双指针，
维护oldStartIndex和oldEndIndex；newStartIndex和newEndIndex；
下来开始循环比较，直到新旧节点的任一组的开始索引大于结束索引。

头头比较：如果新旧开始节点相同，则递归比较子节点，oldStartIndex++，newStartIndex++；
尾尾比较：如果新旧结束节点相同，则递归比较子节点，oldEndIndex--，newEndIndex--；
头尾比较：如果新旧开始节点和新结束节点相同，将旧开始节点移动到旧结束节点后面，oldStartIndex++，oldEndIndex--；
尾头比较：如果新旧结束节点和新开始节点相同，将旧结束节点移动到旧开始节点前面，oldStartIndex--，oldEndIndex++；

如果以上四种情况都没有匹配上
创建旧节点的key到索引的映射
在旧节点数组中查找与newStartIndex 具有相同 key 的节点
如果没找到，说明是新增节点，直接创建节点插入到oldStartIndex 位置
如果找到了，说明是移动节点，将该节点移动到oldStartIndex 位置，将旧节点设为null，说明已处理
newStartIndex++

之后 新多就新增节点，旧多就删除节点


vue3：

主要分为五步：从前向后->从后向前->新节点多于旧节点->旧节点多于新节点->乱序。

1. 从前向后遍历新旧节点数组，判断其相同index的节点的type和key，如果相同则patch，否则break。

2. 从后向前遍历新旧节点数组，判断其相同index的节点的type和key，如果相同则patch，否则break。

3. 经过前两次的diff后，根据新节点的位置，进行选取锚点的操作，而后patch。

4. 经过前三次的diff，判断销毁节点的位置，直接执行unmount。

5. 经过前四次的diff，剩下的没有更新的序列为乱序序列
- 构建新节点的 key 到索引的映射
- 尝试在旧节点中找到可复用的节点，构建新节点在旧节点中的位置映射
- 计算最长递增子序列（节点的移动）
- 从后向前遍历，移动或新增节点：
  - 如果节点在最长递增子序列中，则不需要移动
  - 如果节点不在最长递增子序列中，则需要移动到正确位置
  - 如果在旧节点中找不到对应节点，则创建新节点



